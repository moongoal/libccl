/**
 * @file
 *
 * A pool whose handles are generated by another pool.
 */
#ifndef CCL_DEPENDENT_POOL_HPP
#define CCL_DEPENDENT_POOL_HPP

#include <ccl/api.hpp>
#include <ccl/concepts.hpp>
#include <ccl/pool.hpp>
#include <ccl/memory/allocator.hpp>

namespace ccl {
    /**
     * A pool that extends another one by providing values of a different type for
     * handles defined by the extended (primary) pool. This allows handles generated
     * by a primary pool to assume multiple values at the same time, depending on
     * which pool the query operation is performed against.
     *
     * @tparam T The value type to store in this pool.
     * @tparam PrimaryPool The primary pool type.
     * @tparam Allocator The allocator to use for data storage.
     */
    template<
        typename T,
        typename PrimaryPool,
        typed_allocator<T> Allocator = allocator
    > class dependent_pool {
        public:
            using value_type = T;
            using pointer = T*;
            using reference = T&;
            using const_reference = const T&;
            using handle_type = typename PrimaryPool::handle_type;
            using allocator_type = Allocator;
            using object_vector_type = paged_vector<value_type, pointer, allocator_type>;
            using primary_pool_type = PrimaryPool;

        private:
            object_vector_type data;
            value_type default_value;
            const primary_pool_type *primary_pool;

        public:
            dependent_pool(
                const primary_pool_type &primary_pool,
                const_reference default_value = T{},
                allocator_type * const allocator = nullptr,
                const allocation_flags alloc_flags = CCL_ALLOCATOR_DEFAULT_FLAGS
            ) : data{allocator, alloc_flags},
                default_value{default_value},
                primary_pool{&primary_pool}
            {}

            constexpr dependent_pool(const dependent_pool& other) = default;
            constexpr dependent_pool(dependent_pool&& other) noexcept = default;

            dependent_pool& operator=(const dependent_pool& other) = default;
            dependent_pool& operator=(dependent_pool&& other) noexcept = default;

            virtual ~dependent_pool() = default;

            /**
             * Set the value for an item from the pool.
             *
             * @param handle The handle of the item to get.
             * @param value The new value to set.
             *
             * @return A reference to the item.
             */
            reference set(const handle_type &handle, const T& value) {
                if(handle.value() >= data.size()) {
                    data.resize(handle.value() + 1);
                }

                return set_unsafe(handle, value);
            }

            /**
             * Unsafely set the value for an item from the pool. This function does not check
             * for or extend the available storage. It can be used to set values in critical
             * paths where storage presence was already ensured by calling `set()`.
             *
             * Calling this function before setting a value is undefined behaviour.
             *
             * @param handle The handle of the item to get.
             * @param value The new value to set.
             *
             * @return A reference to the item.
             */
            reference set_unsafe(const handle_type &handle, const T& value) {
                CCL_THROW_IF(!is_valid(handle), std::invalid_argument{"Invalid handle."});
                CCL_THROW_IF(handle.value() >= data.size(), std::invalid_argument{"Dependent handle slot not initialised."});

                return data[handle.value()] = value;
            }

            /**
             * Get an item from the pool. An old (used in the past but free now) handle
             * will return the default value. A handle never acquired via the primary pool
             * will generate undefined behaviour.
             *
             * @param handle The handle of the item to get.
             *
             * @return A reference to the item.
             */
            CCLNODISCARD const_reference get(const handle_type &handle) const {
                CCL_THROW_IF(!is_valid(handle), std::invalid_argument{"Invalid handle."});

                return data[handle.value()];
            }

            /**
             * Get an item from the pool. An old (used in the past but free now) handle
             * will return the default value. A handle never acquired via the primary pool
             * will generate undefined behaviour. Setting the value of a reference
             * obtained via an old handle will produce undefined behaviour.
             *
             * @param handle The handle of the item to get.
             *
             * @return A reference to the item.
             */
            CCLNODISCARD reference get(const handle_type &handle) {
                CCL_THROW_IF(!is_valid(handle), std::invalid_argument{"Invalid handle."});

                return data[handle.value()];
            }

            /**
             * Set all items to their default value.
             */
            void reset() {
                std::fill(data.begin(), data.end(), default_value);
            }

            /**
             * Reset a single item. The item must have been previously
             * `set()`.
             *
             * @param handle The item handle.
             */
            void reset(const handle_type &handle) {
                set_unsafe(handle, default_value);
            }

            /**
             * @see pool::is_valid()
             */
            bool is_valid(const handle_type &handle) const { return primary_pool->is_valid(handle); }

            constexpr allocation_flags get_allocation_flags() const noexcept { return data.get_allocation_flags(); }
    };
}

#endif // CCL_DEPENDENT_POOL_HPP
