/**
 * @file
 *
 * A pool whose handles are generated by another pool.
 */
#ifndef CCL_DEPENDENT_POOL_HPP
#define CCL_DEPENDENT_POOL_HPP

#include <ccl/api.hpp>
#include <ccl/concepts.hpp>
#include <ccl/pool.hpp>
#include <ccl/memory/allocator.hpp>

namespace ccl {
    /**
     * A pool that extends another one by providing values of a different type for
     * handles defined by the extended (primary) pool. This allows handles generated
     * by a primary pool to assume multiple values at the same time, depending on
     * which pool the query operation is performed against.
     *
     * @tparam T The value type to store in this pool.
     * @tparam PrimaryPool The primary pool type.
     * @tparam Allocator The allocator to use for data storage.
     */
    template<
        typename T,
        typename PrimaryPool,
        typed_allocator<T> Allocator = allocator
    > class dependent_pool {
        public:
            using value_type = T;
            using pointer = T*;
            using reference = T&;
            using const_reference = const T&;
            using handle_type = typename PrimaryPool::handle_type;
            using allocator_type = Allocator;
            using object_vector_type = paged_vector<value_type, pointer, allocator_type>;
            using primary_pool_type = PrimaryPool;

        private:
            object_vector_type data;
            value_type default_value;
            const primary_pool_type *primary_pool;

        public:
            dependent_pool(
                const primary_pool_type &primary_pool,
                const_reference default_value = T{},
                allocator_type * const allocator = nullptr

            ) : data{allocator},
                default_value{default_value},
                primary_pool{&primary_pool}
            {}

            constexpr dependent_pool(const dependent_pool& other) = default;
            constexpr dependent_pool(dependent_pool&& other) noexcept = default;

            dependent_pool& operator=(const dependent_pool& other) = default;
            dependent_pool& operator=(dependent_pool&& other) noexcept = default;

            virtual ~dependent_pool() = default;

            /**
             * Set the value for an item from the pool.
             *
             * @param handle The handle of the item to get.
             * @param value The new value to set.
             *
             * @return A reference to the item.
             */
            reference set(const handle_type &handle, const T& value) {
                CCL_THROW_IF(!is_valid_handle(handle), std::invalid_argument{"Invalid handle."});

                return data[handle.value()] = value;
            }

            /**
             * Get an item from the pool. An old (used in the past but free now) handle
             * will return the default value. A handle never acquired via the primary pool
             * will generate undefined behaviour.
             *
             * @param handle The handle of the item to get.
             *
             * @return A reference to the item.
             */
            CCLNODISCARD const_reference get(const handle_type &handle) const {
                return data[handle.value()];
            }

            /**
             * Get an item from the pool. An old (used in the past but free now) handle
             * will return the default value. A handle never acquired via the primary pool
             * will generate undefined behaviour. Setting the value of a reference
             * obtained via an old handle will produce undefined behaviour.
             *
             * @param handle The handle of the item to get.
             *
             * @return A reference to the item.
             */
            CCLNODISCARD reference get(const handle_type &handle) {
                return data[handle.value()];
            }

            /**
             * Set all items to their default value.
             */
            void reset() {
                std::fill(data.begin(), data.end(), default_value);
            }

            /**
             * @see pool::is_valid_handle()
             */
            bool is_valid_handle(const handle_type &handle) const { return primary_pool->is_valid_handle(handle); }

            /**
             * Register a handle coming from the primary pool against this pool to
             * ensure its value is allocated and initialised. This function must be called
             * only once, when the handle is first acquired.
             *
             * @param handle The handle to populate the data for.
             *
             * @return A reference to the new value.
             */
            reference populate(const handle_type handle) {
                CCL_THROW_IF(!is_valid_handle(handle), std::invalid_argument{"Invalid handle."});

                if(handle.value() >= data.size()) {
                    data.resize(handle.value() + 1);
                }

                return set(handle, default_value);
            }

            /**
             * Register a handle coming from the primary pool against this pool to
             * ensure its value is allocated and initialised. This function must be called
             * only once, when the handle is first acquired.
             *
             * @param handle The handle to populate the data for.
             * @param initial_value The initial value to associate with the handle.
             *
             * @return A reference to the new value.
             */
            reference populate(const handle_type handle, const_reference initial_value) {
                CCL_THROW_IF(!is_valid_handle(handle), std::invalid_argument{"Invalid handle."});

                if(handle.value() >= data.size()) {
                    data.resize(handle.value() + 1);
                }

                return set(handle, initial_value);
            }
    };
}

#endif // CCL_DEPENDENT_POOL_HPP
